\chapter{Theoretical Considerations}
\section{State-of-the Art Development Environment}
CI
Unit Testing
Model driven design
Autogenerated Docs
\section{Architectural Considerations}
\subsection{Performance}
\subsubsection{fxtlib}
\subsubsection{move semantics when operating on model}

\subsection{Cross-Platform Operation}
\subsubsection{Qt Framework}
QApplication, main event loop

\subsubsection{Dynamic Library Loading}
POSIX Systems use dlopen()

Windows uses LoadLibrary()

To get cross-platform operation without recompiling, use Qt's Library loading mechanism: QPluginLoader

\subsubsection{QtQuick}
QML integrate in C++

QRC QtResourceCollection

qml files are not compiled (javascript like)
Actually based on ECMAScript6 aka. JavaScript

\subsubsubsection{Signals and Slots in QML}
Signals are captured by invoking Signal Handlers

\subsubsubsection{Qt and C++1y}
Move semantics not implemented
QQuickItem has disabled copy ctor and no move ctor
use unique_ptrs to copy without resource leaks


\subsection{Extensibility}
\subsubsection{Plugin Structure}
Lower app startup times, not every importer exporter is needed on every app run

Easy to extend the app with new importers / exporters without touching other internal code

Plugins encapsulated by Shared Libraries can be published to the app, registry of available plugins can be read from config file.

No recompilation needed on adding/removing plugins.

Each plugin must share a common interface though

\section{Design Patterns}
\subsection{Registry Pattern}

\subsection{Factory Pattern}

\subsection{Builder Pattern}

\subsection{Singleton}
Single instance + easy global access from all classes of the app
