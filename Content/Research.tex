\chapter{Research and Architecture Definition}

\section{State-of-the Art Development Environment}
CI
Unit Testing
Model driven design
Autogenerated Docs
\section{Architectural Considerations}

\subsection{Plugin Architecture}
Looking at the requirements, it is apparent, almost all component have disjunt responsibilities, their main common element being the string description of the PFC they operate on.

The \term[Lindenmeyer System]{LSYS} generator takes some input and outputs a model string. GUI, SVG and PDF renderings all operate on the model, but don't influence each others operation.

This characteristic is conducive to segregating those components of the app not just to different classes, but to completely separate compilation units, i.e. standalone libraries called plugins.

In conjunction with a dynamic loading system, this confers several benefits:

- Reduced compilation time of the main application
- Extensibility without recompilation
- 

This architecture also comes with drawbacks
- Updating the main app with changes breaking public APIs used by plugins will fail at runtime until all plugins have been updated/recompiled
- If plugins have dependencies on other plugins, maintenance complexity grows exponentially.

Since plugins to pfcrender will mainly consist of new Import/Export formats with limited intrinsic complexity and no dependencies on other plugins, the following architecture was chosen




\subsection{Configuration}
Main considerations:
- Want all options to be command line selectable
- Want documentation of available commandline options
- Options are provided by components of the GUI as well as by plugins

It is inefficient to create objects just to query for their config info
All possible config options must be known by the time the cmdline is parsed for CLI documentation and type checking. While it is possible to query all plugins for that info by this time, other components of the app requiring/exporting config values do not necessarily exist at that time.

This is a catch-22 type situation, where compromise needs to be made. Since I want full CLI documentation, and I dont want to have a list of manuallz specified CLI options that inevitably desyncs with its objects, I decided to compromise on the following:

Instead of specifying CLI options centrally, each object that wants to export configuration options, inherits a Configurable* interface that can be used to query the static config options.
Classes in the main app that can be configured are centrally stored in a list in the Config_Store singleton (i.e. new classes that are configurable must inherit the interface and be _manually_ added to the list).
Classes from interfaces are queried for their config options on app startup.

While this is a non-nice gotcha for developers of the main app, it enables plugin writers to easily extend the CLI


Another option is to build a compile-time list of configurable classes in the main compilation unit. As all plugins are instantiated before CLI parsing anyway, the list of options can be completed then.
Building a compile-time list uses template metaprogramming though
	https://stackoverflow.com/questions/9975672/c-automatic-factory-registration-of-derived-types

Unlike in the GUI, where we can check for config options once the object using them is instantiated, the CLI batch mode runs a preset sequence of steps and needs to gather all available/acceptable config options before starting the process in order to generate meaningful CLI documentation.	

Automatic gathering of classes that export configuration is only possible at compile time, as the compiler goes through each source file. A runtime object of a class might not exist until long after CLI parsing	


Solution - auto registration of class with a typelist ?
https://stackoverflow.com/questions/42077057/c14-metaprogramming-automagically-build-a-list-of-types-at-compile-init-tim?rq=1

Interfaces - CLIconfig, GUIconfig

The selected architecture defines an order of precedence of config options:
1. Global options are set from config file is parsed
2. options give on Command line are set 
3. GUI options can set config settings

\subsection{Performance}
\subsubsection{fxtlib}
\subsubsection{move semantics when operating on model}

\subsection{Cross-Platform Operation}
\subsubsection{Qt Framework}
QApplication, main event loop

\subsubsection{Dynamic Library Loading}
POSIX Systems use dlopen()

Windows uses LoadLibrary()

To get cross-platform operation without recompiling, use Qt's Library loading mechanism: QPluginLoader

\subsubsection{QtQuick}
QML integrate in C++

QRC QtResourceCollection

qml files are not compiled (javascript like)
Actually based on ECMAScript6 aka. JavaScript

declarative as opposed to the imperative  C++

\subsubsubsection{Signals and Slots in QML}
Signals are captured by invoking Signal Handlers

\subsubsubsection{Qt and C++1y}
Move semantics not implemented
QQuickItem has disabled copy ctor and no move ctor
use unique_ptrs to copy without resource leaks


\subsection{Extensibility}
\subsubsection{Plugin Structure}
Lower app startup times, not every importer exporter is needed on every app run

Easy to extend the app with new importers / exporters without touching other internal code

Plugins encapsulated by Shared Libraries can be published to the app, registry of available plugins can be read from config file.

No recompilation needed on adding/removing plugins.

Each plugin must share a common interface though

\section{Design Patterns}
\subsection{Registry Pattern}

\subsection{Factory Pattern}

\subsection{Builder Pattern}

\subsection{Singleton}
Single instance + easy global access from all classes of the app


\section{Problems}
\subsection{Model Creation}
QQuickPaintedItem uses a given painter, explicitly calling functions on it to draw on a paint device.
We want the finished image though, not something that draws based on input. We would need to embed the LSYS string into the model if that were the case.

Und jetzt habe ich die Wahl was ich in der GUI als Modell der PFC speichere, bisherige Überlegungen:
- Den String selbst
Die Ideen sind wohl halbwegs speicheroptimal, müssen aber wohl entweder ein ViewModel zwischengeschaltet bekommen, bevor sie renderbar werden, was den Speichervorteil zunichte macht, oder auf ein Canvasobjekt "gemalt" werden
- Als SVG. Einfach zu rendern, aber den SVG overhead zu parsen ist sicher alles andere als performant.

Model: - 2D - Matrix in der jeder Index ein Segment mit Richtung und Farbe repräsentiert

- Ein QML-Objekt (QQuickPaintedItem), das den LSYS String als member enthält und neu zeichnen lässt (bessere Austauschbarkeit des Modells - nicht limitiert auf PFCs)
- Ein generisches QQuickItem, das als Information direkte OpenGL drawing calls enthält (QSGGeometry)

Das Model muss weiterhin nicht nur als Bitmap renderbar, sondern in verlustfreier Form z.B. nach SVG exportierbar sein - die Daten z.B. nur in einer QSGGeometry vorzuhalten ist praktisch zum rendern (automatisch in Qt), aber unmöglich aus dem Quickitem wieder zu extrahieren


\section{Chosen Application Architecture}

\figure{fullrequirements.png}



\section{Flexible Buildsystem}
Due to the requirement of a Multi-platform architecture, one of the first considerations is how to get the program code built.

Though it would surely be possible to have the platform agnosstic sources present, and then manually create a project for MSVC/MinGW when on Windows, gnu gcc on Linux and clang on Mac, this would be a pain to set up and maintain.

Solutions to this problem exist in so-called buildsystem generators. Those gather sources, dependencies and additional project information from a configuration file, detect the architecture they are running on, and generate the files necessary to compile the full project on whichever compiler is present on the current system.

QMake - The native buildsystem generator of Qt, uses .pro files for project description

CMake - A powerful and scalable config script-driven generator that is widely used in both Open Source and commercial projects 


\section{Commandline Parsing}
Unlike other programming languages (e.g. Python), C++ does not provide a standard built-in facility to provide parsing capability for parsing parameters passed to the program as commandline options.

Alternatives:

\begin{itemize}
\item getopt() - Coming from C, this is a legacy method widely used on Linux. Since it is specific to POSIX systems, it cannot be used on Windows 
\item Boost.progam_options - A C++ native, highly configurable solution shipped with the open source Boost library
http://www.boost.org/doc/libs/1_58_0/doc/html/program_options.html
\item QtCommandLineParser - A Qt native parsing class. Batch-parses all parameters and returns data structures with positional arguments in correct order, and a (reordered) map of switches with their parameters
http://doc.qt.io/qt-5/qcommandlineparser.html
\item Manual parsing of the argv array. While this is the most flexible solution in customization, it is reinventing the wheel and also very inflexible with respect to extensibility.

Due to it supporting our use-case, being easily extensible and not introducing any more dependencies into the project above the already used Qt Framework libraries, the QtCommandLineParser was chosen to provide the main CLI-based interface to the program.


\section{Option Persistency}
Since it is often unneccessary to set any and all config options for the program on the command line each time it is run, keeping config options persistently over program relaunches is useful. The typical implementation of this persistent store again varies by platform, ranging from putting keys into the Windows registry, over property list files on Mac to plain .ini or .cfg files on Linux.

Again, Qt comes with a wrapper around this platform disparity
