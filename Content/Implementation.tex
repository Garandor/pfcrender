\chapter{Architecture Implementation}
\section{Application Configuration / Development Environment}

\subsection{Build System}
Travis CI / Codecov.io

Huge benefit to maintainability, clear insight on testing, fast feedback whether changes work.

Only feasible way to confirm multiplatform functionality without running 3 separate dev environments

They turned out to eat up about as much productivity in maintenance as they freed

Travis CI runs on Ubuntu 12.04LTS which reached End-of-Life in 2017. Ubuntu 14.04LTS support is still experimental, but even with the updated OS, the available tools are heavily outdated.

Standard gcc is a v4 with no support for C++11
Manually updating tools had ramifications as gcov was now ouptutting coverage data from gcov-5, lcov was using the old gcov-4 leading to no coverage being reported. Manually setting the gcov tool path resolved this issue, which - along with the time spent identifying the problem - was a significant time drain.

Still, the great benefit of this tool is that once it has been set up, it "just works" - running alongside the projects dev flow unintrusively and gives good insight into areas of improvement.

\section{Application configuration}

\section{Plugin Interface abstraction}
\subsubsection{Inheritance in Qt}
Implementing interfaces that are supposed to be used with Qt's meta object system is a slightly awkward procedure, as Qt's macros used to notify the moc about interface definitions and implementations are not namespace aware. 

This limitation pertains to interfaces exposing functionality from the Qt MetaObject system like signals/slots.

\section{Curve Creation}

\section{Graphical Output}
\subsection{Rendering the Model Curve}
While a PFC can be constructed segment by segment, the final size and position of the curve is not known until after the full curve is constructed.

The smallest rectangle fitting around a curve rendering is called its  \gls{bounding box}

Since the extent is not known beforehand, the resulting drawing must be transformed in such a way as to fit the given drawing device (screen, bitmap).

The resulting transformation can be done with a translation and scaling of the bounding box.

A performance-optimal way of calculating the bounding box is picking up minimum and maximum coordinates alongside the drawing avoiding a second parsing run of the model string.

Since the \gls{QPainter} API used by Qt is iterative in nature (\gls{QPainter} API), the transformation must be set before drawing begins. Setting a transformation only affect future drawing calls.

Using \gls{QPainter} thus forces precomputing of the bounding box.


\section{SVG Output}
\label{sec:svg}

\section{PDF Output}
\label{sec:pdf}

\section{Challenges faced during Implementation}

\subsection{Custom Geometry dunt werk liek it should}
