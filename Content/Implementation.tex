\chapter{Architecture Implementation}
\section{Application Configuration / Development Environment}
\subsection{QtCreator}

QtCreator is an \gls{ide} originally created for creating GUI apps using the Qt libraries. It brings integration with many useful third-party tools though.

QML Designer

It can natively parse CMake-defined projects

It can run and visualize tests

It has integration with static and dynamic analysis tools like clang-analyzer and valgrind (including code profiling with callgrind)

It integrates support to automatically format code with clang-format and astyle, enforcing uniform code formatting as propsed in section \ref{sec:resformat}

\todo{images}

\subsection{Build System}
Setting up the \gls{ci} environment is a pain, mainly caused by Travis using a 6 year old Linux distribution by default, where the standard version of gcc is 4.8, which does not even support C++11.



\section{Application configuration}

\section{Plugin Interface abstraction}
\subsubsection{Inheritance in Qt}
Implementing interfaces that are supposed to be used with Qt's meta object system is a slightly awkward procedure, as Qt's macros used to notify the moc about interface definitions and implementations are not namespace aware. 

This limitation pertains to interfaces exposing functionality from the Qt MetaObject system like signals/slots.

\section{Curve Creation}

\section{Graphical Output}
\subsection{Rendering the Model Curve}
While a PFC can be constructed segment by segment, the final size and position of the curve is not known until after the full curve is constructed.

The smallest rectangle fitting around a curve rendering is called its  \gls{bounding box}

Since the extent is not known beforehand, the resulting drawing must be transformed in such a way as to fit the given drawing device (screen, bitmap).

The resulting transformation can be done with a translation and scaling of the bounding box.

A performance-optimal way of calculating the bounding box is picking up minimum and maximum coordinates alongside the drawing avoiding a second parsing run of the model string.

Since the \gls{QPainter} API used by Qt is iterative in nature (\gls{QPainter} API), the transformation must be set before drawing begins. Setting a transformation only affect future drawing calls.

Using \gls{QPainter} thus forces precomputing of the bounding box.


A way was found to avoid reparsing the model string for the sole purpose of obtaining a bounding box for rendering.
The bounding box is instead calculated in the the same parsing pass used to draw the geometry. The drawing frameworks can not translate after drawing, but the Qt SceneGraph can.

Using the translate property, which - under the hood - prepends the actual scenegraph node with a QSGTransformNode, the rendering can be done without concern for target coordinates and moved to fit the window after drawing.

\subsection{Custom Geometry dun werk liek it should}
\label{sec:implrenderprob}
arcs bezier
\section{SVG Output}
\label{sec:svg}

\section{PDF Output}
\label{sec:pdf}


\section{Automated Unit Testing and Coverage Reporting}
A main benefit of using Github - as already stated, is the third party tool integration offered.

Regarding unit testing, this results in the possibility to not only automatically run tests on each build of Travis CI, but also visualize the \gls{coverage} of the tests executed using \url{codecov.io}, which hooks into Travis completed builds that generated code output with coverage information and generates a graphical report on which lines of code were actually executed during testing.

They turned out to eat up about as much productivity in maintenance as they freed

Travis CI runs on Ubuntu 12.04LTS which reached End-of-Life in 2017. Ubuntu 14.04LTS support is still experimental, but even with the updated OS, the available tools are heavily outdated.

Huge benefit to maintainability, clear insight on testing, fast feedback whether changes work.

Standard gcc is a v4 with no support for C++11
Manually updating tools had ramifications as gcov was now ouptutting coverage data from gcov-5, lcov was using the old gcov-4 leading to no coverage being reported. Manually setting the gcov tool path resolved this issue, which - along with the time spent identifying the problem - was a significant time drain.

Still, the great benefit of this tool is that once it has been set up, it "just works" - running alongside the projects dev flow unintrusively and gives good insight into areas of improvement.
\todo{lolwut}
