\chapter{Architecture Implementation}

\subsection{Rendering the Model Curve}
While a PFC can be constructed segment by segment, the final size and position of the curve is not known until after the full curve is constructed.

The smallest rectangle fitting around a curve rendering is called its \term[In 2D graphics, denotes the smallest possible rectangle that fully contains a given geometric shape]{bounding box}.

Since the extent is not known beforehand, the resulting drawing must be transformed in such a way as to fit the given drawing device (screen, bitmap).

The resulting transformation can be done with a translation and scaling of the bounding box.

A performance-optimal way of calculating the bounding box is picking up minimum and maximum coordinates alongside the drawing avoiding a second parsing run of the model string.

Since the \term QPainter API used by Qt is iterative in nature (\term QPainter API), the transformation must be set before drawing begins. Setting a transformation only affect future drawing calls.

Using \term QPainter thus forces precomputing of the bounding box.


\subsubsubsection{Inheritance in Qt}
Implementing interfaces that are supposed to be used with Qt's meta object system is a slightly awkward procedure, as Qt's macros used to notify the moc about interface definitions and implementations are not namespace aware. 

This limitation pertains to interfaces exposing functionality from the Qt MetaObject system like signals/slots.

\section{Architectural Considerations}

\subsection{Painting in Qt}
Qt uses an iterative API for 2D graphics named QPainter.

It is a stateful 

A transformation matrix can be applied on all drawing calls,

\subsection{Configuration}

\subsubsubsection{Signals and Slots in QML}

\subsubsubsection{Qt and C++1y}

\subsection{Extensibility}
\subsubsection{Plugin Structure}

\section{Problems}
\subsection{Model Creation}
