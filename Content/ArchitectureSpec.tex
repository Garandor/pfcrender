\chapter{Chosen Application Architecture}

After researching available technologies, an architecture to build the pfcrender tool on was selected. The implementation is shown alongside the original requirements in the following graphs, split between functional- (figure \ref{fr}) and non-functional (figure \ref{nfr}) requirements. As before, direct requirements are highlighted in green. Take note that each direct requirement is satisfied or verified through an implementation requirement or test case.

The architecture is discussed in detail in the following sections.

\begin{figure}[p]
	\includegraphics[width=\textwidth]{FunctionalRequirements}
	\caption{Functional requirements}
	\label{fr}
\end{figure}

\begin{figure}[p]
	\includegraphics[width=\textwidth]{Non-FunctionalRequirements}
	\caption{Non-functional requirements}
	\label{nfr}
\end{figure}

\section{Functional Requirements}
The main decision to make on the software architecture side was which of the framework libraries discussed in section \ref{sec:res_frameworks} to use.
Selection was driven by three main concerns: extensibility, performance and ease-of-use.

Ultimately, the Qt Framework was chosen for the following reasons:
\begin{itemize}
	\item Platform-independent dynamic library loading abstraction provided, which is useful for implementing a plugin architecture as described in \ref{sec:pluginarch}
	\item Classes provided for exporting e.g. to SVG and PDF
	\item The QtQuick API exposes direct OpenGL access, i.e. rendering performance is assumed to be comparable to the more light-weight frameworks like \gls{sdl}
	\item Multiple quality-of-life improvements like the QtCreator \gls{ide} with \gls{gui} designer
	\item Included QtTest Unit-Testing Framework
\end{itemize}

Qt provides most of the wanted features in one framework, reducing the amount of necessary dependencies to provide all required functionality. The only additional dependency to Qt introduced to the project is the drawing \gls{api} QNanoPainter(\ref{sec:qnanopainter}), which was introduced as manipulating OpenGL geometry directly proved unwiedly for rendering arcs (see \ref{sec:implrenderprob})

A description of the Qt provided mechanisms used in this tool follows

\subsection{Dynamic Library Loading}
Windows DLL API mandates symbols callable from outside a library to be prefixed with a macro on export and import. The \gls{msdn}\furl{https://msdn.microsoft.com/en-us/library/3y1sfaz2.aspx} defines it the following way
\begin{lstlisting}
__declspec( dllimport ) declarator  
__declspec( dllexport ) declarator  
\end{lstlisting}

Linux compilers like gcc will not be able to parse this keyword and fail compilation. While it is possible to work around this issue by wrapping the keyword in a preprocessor macro that expands to nothing on Linux, this mechanism is cumbersome to implement.

Qt provides a wrapper around this functionality with QPluginLoader. This mechanism involves some extra steps compared to loading a shared library directly, which pertain to making the Qt MetaObject system aware of the plugin\furl{http://doc.qt.io/qt-5/plugins-howto.html}, but spares the effort of including platform specific adapter code/preprocessor instructions to each plugin.

\subsection{Rendering in Qt}
\label{sec:qtrender}
As stated before, Qt offers two different application programming \gls{api}s. A main difference is in the rendering methode they use:
\begin{description}
	\item [QWidgets] The main API of Qt. It is similar to Java SWING and handles GUI design and functionality in C++ using Qt-provided or custom QWidget-derived classes.
	\item [QtQuick] A relatively new (since Qt 4.7) javascript-based declarative language called \gls{qml}, similar to the XML-based JavaFX, is used to define the GUI frontend, while C++ classes in the backend are used for performance intensive calculation. The UI is then rendered in a so-called scenegraph using a platform specific graphics backend like OpenGL or OpenGL ES. Though no formal study of performance differences between both \gls{api}s exists, documentation by the QtCompany\furl{http://doc.qt.io/qt-5/qtquick-performance.html} suggests performance between both models is comparable if some guidelines are followed.
\end{description}

Since the additional model-/view abstraction is conducive to extensibility of the tool, as the declarative \gls{qml} language makes GUI extensions simple, QtQuick is selected for the implementation.


The following methods of drawing to these APIs are offered:
\begin{description}
	\item [QPainter] Oldest drawing API of Qt, used in QWidgets. Not directly usable in QtQuick. Offers highest amount of integration to other Qt classes (notably QPrinter and QSVGGenerator)
	\item [QtQuick/QML shape] Placing line segments directly in a \gls{qml} file and loading it to the SceneGraph (creating quadratic bezier curves added in Qt 5.10 (late 2017), too late for this work\furl{https://blog.qt.io/blog/2017/08/10/let-there-be-more-shapes/})
	\item [QtQuick HTML5 canvas] Draws on top of a HTML5 canvas embedded into the qt app.
	\item [QtQuick Item with custom scene graph node] Instantiates a QQuickItem with a custom appearance by setting vertices and material directly\todo{explain what those are}
	\item [QQuickPaintedItem] An adaptation of the QPainter API for the SceneGraph based QtQuick. 
	\item [QNanoPainter] A third party plugin, offering a mixture of QPainter and HTML5 canvas API to draw on an OpenGL framebuffer object to be placed in the QtQuick scene graph. Offers Painter-like productivity with less performance overhead.
\end{description}

The QML and HTML5 APIs were disregarded due to their interpreted and thus slow nature.

This leaves direct QuickItem implementation, QQuickPaintedItem and QNanoPainter-based QuickItem as viable options.

Due to performance measurements\furl{https://www.vikingsoftware.com/qtquick-custom-item-performance/}, a direct implementation was chosen intially (see \ref{somewhere}). The operations performed using this \gls{api} were too inflexible to allow for generation of quadratic b√©zier curves necessary to implement rounded edges (see \ref{somewhere}), so a higher level \gls{api} was selected.

Further performance benchmarks\furl{http://kgronholm.blogspot.com/2017/12/qt-510-rendering-benchmarks.html} led to preferring QNanoPainter over the built-in QQuickPaintedItem, even though it meant introducing an additional dependency into the project.

It is worth noting, that QPainter \gls{api} was still used for file outputs (see \ref{svg}, \ref{pdf}), where performance is not as critical, due to its integration with other Qt exporter classes.

\subsection{Configuration}
It was decided to introduce a central store of configuration that will be accessible to the entire application using the Singleton pattern discussed in section \ref{sec:ston}.

Each plugin is required to publish and read its configuration options from this central store.

We define the following possibilities of setting options in this this central store:
\begin{enumerate}
	\item A configuration file stores set options and persists application state between runs
	\item Options can be given on the Command line
	\item Options can be set from within the GUI
\end{enumerate}

\subsubsection{QSettings}
The Qt framework comes with a provider for storing settings called QSettings 

\todo{asd}

\subsubsection{QCommandlineParser}
Parsing of the commandline is one of the first steps in program execution. Since successfully parsing given arguments (and generating --help documentation on available options) requires all available options to be known, it follows that all plugins must be loaded on startup to query them for their config options.

While this is not computationally efficient, as not all plugins will necessarily be executed during program runtime and thus get loaded in vain, maintainability outweighs this performance issue.
Loading all plugins is a once-per-execution process and the number of plugins is fairly small. Also, loading all plugins at startup allows for automatically gathering a available functionality on startup, omitting the need for a separate configuration file of plugins and their locations.

It is thus defined that plugin libraries will be located in a Plugins subfolder below the binary executable and are loaded at runtime each time the program executes.

This design allows for a \emph{self-documenting, truly runtime extensible} plugin system, where plugins can be added/removed from the program without additional configuration steps.

Due to it supporting our use-case, being easily extensible and not introducing any more dependencies into the project above the already used Qt Framework libraries, the QtCommandLineParser was chosen to provide the main CLI-based interface to the program.

A drawback of QCommandlineParser is the batch parsing of the commandline, making it impossible to group \-\-switches by their position of occurrence.

We thus define the following:
\begin{enumerate}
	\item Actions taken by the program shall be specified on the commandline as positional arguments (with no - prefix), to guarantee their execution in order
	\item configuration options are specified with \-\-prefix and shall be unique throughout the application (including all plugins)
\end{enumerate}

\subsubsection{GUI configuration}
In order to make configuration possible from the GUI, a plugin shall expose a configuration screen QQuickItem object through its plugin interface that contains all logic for setting configuration options on the plugin for the GUI to display.

\section{Non-functional Requirements}

\subsection{Qt Unit Testing Framework}
Qt comes with its own unit-testing framework integrated into QtCreator. The following code presents an example test for a fictional Counter class:

\begin{lstlisting}
#include <QtTest>
#include "Counter.h"

class MyTest : public QObject {
    Q_OBJECT

    Counter* ctr;

private slots:
    void initTestCase();

    void do_count();
  //void do_downcount(); // additional test routines

    void cleanupTestCase();
};

void MyTest::initTestCase()
{
	ctr = new Counter(0);
}

void MyTest::cleanupTestCase()
{
    delete ctr;
}

void MyTest::do_count()
{
	ctr->count();
	QVERIFY(ctr->getValue() == 1);
}

QTEST_MAIN(MyTest)
#include "MyTest.moc"
\end{lstlisting}

This builds an executable (main routine provided by the QTEST\_MAIN macro) that runs the given test routines.
It is integrated with QtCreator, which gathers test apps created in this way automatically and can run them from the \gls{gui} and display PASS/FAIL status depending on QVERIFY() and return value.
\begin{figure}[h]
\end{figure}
	\todo{qtcreatbild}

Since it is a standalone executable, it can also be run by other testing environments like CMake's CTest, and can thus be automated and integrated into \gls{ci} builds.

\begin{figure}[h]
\end{figure}
	\todo{travis buildlog}

\subsection{Makefile Generator - CMake}
Though as described in section \ref{sec:resMakefileGen} Qt has its own makefile generator with qmake, CMake was selected for the following reasons
\begin{description}
	\item[good support in \gls{ci} software] Both selected \gls{ci} solutions support 
	\item[widespread use] CMake is extensively documented 
	\item[CTest Test-Runner] Allows to define available unit tests in CMake configuration files and automatically run them after build completion 
\end{description}

Especially the last argument is a large gain for maintainability when integrated with \gls{ci}, as it makes automated builds more informative.
A \gls{ci} build will not only report failure on changes that break compilation, but also on changes that break functionality for which tests exist. This in turn encourages contributors to actually write unit tests, since they don't need to be run manually.


\subsection{Version Control System}
Due to the useful issue tracking feature of github and its extensive third party infrastructure integration with the services like \gls{ci}, git was chosen as \gls{vcs} and github as the central repository provider.

\subsection{CI provider}
Github integration, and free-for-open source service, led to Appveyor being selected as \gls{ci} provider for windows builds, and Travis CI for Linux and MacOS X.

\section{Architecture Hierarchy}
\begin{figure}
	\includegraphics[width=\textwidth]{PluginArchitecture}
	\caption{Main application and plugin separation}
	\label{fig:comp}
\end{figure}

The definitions from this chapter lead to the component architecture showin in figure \ref{fig:comp}. While the GUI could in theory be designated an export plugin as well and extracted from the main application, leaving the possibility to configure operation from the GUI was deemed useful. As this would depend on the GUI plugin receiving the QQuickItem config screen from the plugins, it would lead to dependencies among plugins, potentially leading to the \textit{plugin hell} situation described in \ref{earlier}.

The big benefit of not binding the application to model import from the LSYS iterator module is in extensibility. This architecture can also easily support a use-case, where a library of pre-iterated strings describing \gls{pfc}s is held in a different "PFC library tool" - e.g. categorized by their canonical names - like \textsc{Gosper's flowsnake} presented earlier - and can be easily integrated into the renderer by providing a plugin.
